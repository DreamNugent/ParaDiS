#pragma once

#ifndef _PDS_M33_H
#define _PDS_M33_H

#include <stdio.h>
#include <string.h>
#include <math.h>

#include "Typedefs.h"

typedef real8 M33[9];

//-----------------------------------------------------------------------------------------------
// Inline 3x3 Matrix Operations
//-----------------------------------------------------------------------------------------------
//
// Summary....
//
//    M33_SET           (m,m00,m01,m02,m10,m11,m12,m20,m21,m22)  : m = | m00 m01 m02 |
//                                                                     | m10 m11 m12 |
//                                                                     | m20 m21 m22 |
//
//    M33_COPY          (ma,mb)     : ma = mb
//    M33_ADD           (ma,mb,mc)  : ma = mb + mc
//    M33_ADD_MS        (ma,mb,s )  : ma = mb + s   (s=scalar)
//    M33_ADD_SM        (ma,s ,mb)  : ma = s  + mb  (s=scalar)
//    M33_SUB           (ma,mb,mc)  : ma = mb - mc
//    M33_SUB_MS        (ma,mb,s )  : ma = mb - s   (s=scalar)
//    M33_SUB_SM        (ma,s ,mb)  : ma = s  - mb  (s=scalar)
//
//    M33_IDENTITY      (m)         : m = | 1 0 0 |
//                                        | 0 1 0 |
//                                        | 0 0 1 |
//
//    M33_ZERO          (m)         : m = | 0 0 0 |
//                                        | 0 0 0 |
//                                        | 0 0 0 |
//
//    M33_ONE           (m)         : m = | 1 1 1 |
//                                        | 1 1 1 |
//                                        | 1 1 1 |
//
//    M33_TRANSLATE     (m,x,y)     : m = | 1 0 x |
//                                        | 0 1 y |
//                                        | 0 0 1 |
//
//    M33_SCALE         (m,x,y,z)   : m = | x 0 0 |
//                                        | 0 y 0 |
//                                        | 0 0 z |
//
//    M33_DIAG          (m,x,y,z)   : m = | x 0 0 |
//                                        | 0 y 0 |
//                                        | 0 0 z |
//
//    M33_ROT_X         (m,rx)      : m = | 1   0        0     | (rx=rotation angle in radians)
//                                        | 0 cos(rx) -sin(rx) |
//                                        | 0 sin(rx)  cos(rx) |
//
//    M33_ROT_Y         (m,ry)      : m = |  cos(ry) 0 sin(ry) | (ry=rotation angle in radians)
//                                        |    0     1   0     |
//                                        | -sin(ry) 0 cos(ry) |
//
//    M33_ROT_Z         (m,rz)      : m = | cos(rz) -sin(rz)  0 | (rz=rotation angle in radians)
//                                        | sin(rz)  cos(rz)  0 |
//                                        |   0        0      1 |
//
//    M33_RIGHT_TO_LEFT (m)         : m = |  1  0  0 |
//                                        |  0 -1  0 |
//                                        |  0  0  1 |
//
//    M33_REFLECT_X     (m)         : m = | -1  0  0 |
//                                        |  0  1  0 |
//                                        |  0  0  1 |
//
//    M33_REFLECT_Y     (m)         : m = |  1  0  0 |
//                                        |  0 -1  0 |
//                                        |  0  0  1 |
//
//    M33_REFLECT_Z     (m)         : m = |  1  0  0 |
//                                        |  0  1  0 |
//                                        |  0  0 -1 |
//
//    M33_ECI_TO_SGI    (m)         : m = |  1  0  0 |
//                                        |  0  1  0 |
//                                        |  0  0 -1 |
//
//    M33_MUL           (ma,mb,mc)  : ma = mb * mc                    (note - ma,mb,and mc must be unique)
//    M33_MUL_MS        (ma,mb, s)  : ma = mb *  s  (s=scalar)        (note - ma==mb okay)
//    M33_MUL_SM        (ma,s ,mb)  : ma = s  * mb  (s=scalar)        (note - ma==mb okay)
//    M33_DET           (m)         : returns determinant(m)
//    M33_INV           (ma,mb)     : ma = inverse(mb)                (note - ma and mb must be unique)
//    M33_TRANSPOSE     (ma,mb)     : ma = transpose(mb)              (note - ma and mb must be unique)
//    M33_NEG           (ma,mb)     : ma = -mb                        (note - ma==mb okay)
//    M33_ABS           (ma,mb)     : ma = abs(mb)                    (note - ma==mb okay)
//    M33_NORMALIZE     (ma,mb)     : ma = mb/max(mb)                 (note - ma==mb okay)
//    V3_M33_V3_MUL     (q,m,p)     : q  = m * p  (postfix multiply)  (note - p==q okay)
//    V3_V3_M33_MUL     (q,m,p)     : q  = p * m  (prefix  multiply)  (note - p==q okay)
//
//-----------------------------------------------------------------------------------------------

#define M33_SET1(m,s)                                   \
{                                                       \
   (m)[0]=(s); (m)[1]=(s); (m)[2]=(s);                  \
   (m)[3]=(s); (m)[4]=(s); (m)[5]=(s);                  \
   (m)[6]=(s); (m)[7]=(s); (m)[8]=(s);                  \
}

//-----------------------------------------------------------------------------------------------

#define M33_SET(m,m00,m01,m02,m10,m11,m12,m20,m21,m22)  \
{                                                       \
   (m)[0]=(m00); (m)[1]=(m01); (m)[2]=(m02);            \
   (m)[3]=(m10); (m)[4]=(m11); (m)[5]=(m12);            \
   (m)[6]=(m20); (m)[7]=(m21); (m)[8]=(m22);            \
}

//-----------------------------------------------------------------------------------------------

#define M33_SET_TENSOR(m,m00,m11,m22,m12,m20,m01)       \
{                                                       \
   (m)[0]=(m00); (m)[1]=(m01); (m)[2]=(m20);            \
   (m)[3]=(m01); (m)[4]=(m11); (m)[5]=(m12);            \
   (m)[6]=(m20); (m)[7]=(m12); (m)[8]=(m22);            \
}

//-----------------------------------------------------------------------------------------------

#define M33_COPY(q,p)                                   \
{                                                       \
   (q)[0]=(p)[0]; (q)[1]=(p)[1]; (q)[2]=(p)[2];         \
   (q)[3]=(p)[3]; (q)[4]=(p)[4]; (q)[5]=(p)[5];         \
   (q)[6]=(p)[6]; (q)[7]=(p)[7]; (q)[8]=(p)[8];         \
}

//-----------------------------------------------------------------------------------------------

#define M33_ADD(a,b,c)                                  \
{                                                       \
   (a)[0]=((b)[0]+(c)[0]);                              \
   (a)[1]=((b)[1]+(c)[1]);                              \
   (a)[2]=((b)[2]+(c)[2]);                              \
   (a)[3]=((b)[3]+(c)[3]);                              \
   (a)[4]=((b)[4]+(c)[4]);                              \
   (a)[5]=((b)[5]+(c)[5]);                              \
   (a)[6]=((b)[6]+(c)[6]);                              \
   (a)[7]=((b)[7]+(c)[7]);                              \
   (a)[8]=((b)[8]+(c)[8]);                              \
}

//-----------------------------------------------------------------------------------------------

#define M33_ADD_MS(a,b,s)                               \
{                                                       \
   (a)[0]=((b)[0]+(s));                                 \
   (a)[1]=((b)[1]+(s));                                 \
   (a)[2]=((b)[2]+(s));                                 \
   (a)[3]=((b)[3]+(s));                                 \
   (a)[4]=((b)[4]+(s));                                 \
   (a)[5]=((b)[5]+(s));                                 \
   (a)[6]=((b)[6]+(s));                                 \
   (a)[7]=((b)[7]+(s));                                 \
   (a)[8]=((b)[8]+(s));                                 \
}

//-----------------------------------------------------------------------------------------------

#define M33_ADD_SM(a,s,b)                               \
{                                                       \
   (a)[0]=((s)+(b)[0]);                                 \
   (a)[1]=((s)+(b)[1]);                                 \
   (a)[2]=((s)+(b)[2]);                                 \
   (a)[3]=((s)+(b)[3]);                                 \
   (a)[4]=((s)+(b)[4]);                                 \
   (a)[5]=((s)+(b)[5]);                                 \
   (a)[6]=((s)+(b)[6]);                                 \
   (a)[7]=((s)+(b)[7]);                                 \
   (a)[8]=((s)+(b)[8]);                                 \
}

//-----------------------------------------------------------------------------------------------

#define M33_SUB(a,b,c)                                  \
{                                                       \
   (a)[0]=((b)[0]-(c)[0]);                              \
   (a)[1]=((b)[1]-(c)[1]);                              \
   (a)[2]=((b)[2]-(c)[2]);                              \
   (a)[3]=((b)[3]-(c)[3]);                              \
   (a)[4]=((b)[4]-(c)[4]);                              \
   (a)[5]=((b)[5]-(c)[5]);                              \
   (a)[6]=((b)[6]-(c)[6]);                              \
   (a)[7]=((b)[7]-(c)[7]);                              \
   (a)[8]=((b)[8]-(c)[8]);                              \
}

//-----------------------------------------------------------------------------------------------

#define M33_SUB_MS(a,b,s)                               \
{                                                       \
   (a)[0]=((b)[0]-(s));                                 \
   (a)[1]=((b)[1]-(s));                                 \
   (a)[2]=((b)[2]-(s));                                 \
   (a)[3]=((b)[3]-(s));                                 \
   (a)[4]=((b)[4]-(s));                                 \
   (a)[5]=((b)[5]-(s));                                 \
   (a)[6]=((b)[6]-(s));                                 \
   (a)[7]=((b)[7]-(s));                                 \
   (a)[8]=((b)[8]-(s));                                 \
}

//-----------------------------------------------------------------------------------------------

#define M33_SUB_SM(a,s,b)                               \
{                                                       \
   (a)[0]=((s)-(b)[0]);                                 \
   (a)[1]=((s)-(b)[1]);                                 \
   (a)[2]=((s)-(b)[2]);                                 \
   (a)[3]=((s)-(b)[3]);                                 \
   (a)[4]=((s)-(b)[4]);                                 \
   (a)[5]=((s)-(b)[5]);                                 \
   (a)[6]=((s)-(b)[6]);                                 \
   (a)[7]=((s)-(b)[7]);                                 \
   (a)[8]=((s)-(b)[8]);                                 \
}

//-----------------------------------------------------------------------------------------------

#define M33_DOT(a,b,c)                                  \
{                                                       \
   (a)  = (b)[0]*(c)[0];                                \
   (a) += (b)[1]*(c)[1];                                \
   (a) += (b)[2]*(c)[2];                                \
   (a) += (b)[3]*(c)[3];                                \
   (a) += (b)[4]*(c)[4];                                \
   (a) += (b)[5]*(c)[5];                                \
   (a) += (b)[6]*(c)[6];                                \
   (a) += (b)[7]*(c)[7];                                \
   (a) += (b)[8]*(c)[8];                                \
}

//-----------------------------------------------------------------------------------------------

#define M33_IDENTITY(m)                                 \
{                                                       \
   M33_SET(m,1.0,0.0,0.0,                               \
             0.0,1.0,0.0,                               \
             0.0,0.0,1.0);                              \
}

//-----------------------------------------------------------------------------------------------

#define M33_ZERO(m)                                     \
{                                                       \
   M33_SET(m,0.0,0.0,0.0,                               \
             0.0,0.0,0.0,                               \
             0.0,0.0,0.0);                              \
}

//-----------------------------------------------------------------------------------------------

#define M33_ONE(m)                                      \
{                                                       \
   M33_SET(m,1.0,1.0,1.0,                               \
             1.0,1.0,1.0,                               \
             1.0,1.0,1.0);                              \
}

//-----------------------------------------------------------------------------------------------

#define M33_PASCAL(m)                                   \
{                                                       \
   M33_SET(m,1.0,1.0,1.0,                               \
             1.0,2.0,3.0,                               \
             1.0,3.0,6.0);                              \
}

//-----------------------------------------------------------------------------------------------

#define M33_HILBERT(m)                                  \
{                                                       \
   (m)[0] = 1.0/(0+0+1);                                \
   (m)[1] = 1.0/(1+0+1);                                \
   (m)[2] = 1.0/(2+0+1);                                \
   (m)[3] = 1.0/(0+1+1);                                \
   (m)[4] = 1.0/(1+1+1);                                \
   (m)[5] = 1.0/(2+1+1);                                \
   (m)[6] = 1.0/(0+2+1);                                \
   (m)[7] = 1.0/(1+2+1);                                \
   (m)[8] = 1.0/(2+2+1);                                \
}

//-----------------------------------------------------------------------------------------------

#define M33_RAND(m,min,max)                             \
{                                                       \
   real8  s = ((real8)((max)-(min)))/RAND_MAX;          \
                                                        \
   (m)[0] = (min)+(s*rand());                           \
   (m)[1] = (min)+(s*rand());                           \
   (m)[2] = (min)+(s*rand());                           \
   (m)[3] = (min)+(s*rand());                           \
   (m)[4] = (min)+(s*rand());                           \
   (m)[5] = (min)+(s*rand());                           \
   (m)[6] = (min)+(s*rand());                           \
   (m)[7] = (min)+(s*rand());                           \
   (m)[8] = (min)+(s*rand());                           \
}

//-----------------------------------------------------------------------------------------------

#define M33_TRANSLATE(m,x,y)                            \
{                                                       \
   M33_SET(m,1.0, 0.0, (x),                             \
             0.0, 1.0, (y),                             \
             0.0, 0.0, 1.0 );                           \
}

//-----------------------------------------------------------------------------------------------

#define M33_SCALE(m,x,y,z)                              \
{                                                       \
   M33_SET(m,(x), 0.0,  0.0,                            \
             0.0, (y),  0.0,                            \
             0.0, 0.0,  (z) );                          \
}

//-----------------------------------------------------------------------------------------------

#define M33_DIAG(m,x,y,z)                               \
{                                                       \
   M33_SET(m,(x), 0.0,  0.0,                            \
             0.0, (y),  0.0,                            \
             0.0, 0.0,  (z) );                          \
}

//-----------------------------------------------------------------------------------------------

#define M33_ROT_X(m,rx)                                 \
{                                                       \
   M33_SET(m,1.0,  0.0  ,   0.0  ,                      \
             0.0,cos(rx),-sin(rx),                      \
             0.0,sin(rx), cos(rx) );                    \
}

//-----------------------------------------------------------------------------------------------

#define M33_ROT_Y(m,ry)                                 \
{                                                       \
   M33_SET(m, cos(ry),0.0,sin(ry),                      \
                0.0  ,1.0,  0.0  ,                      \
             -sin(ry),0.0,cos(ry) );                    \
}

//-----------------------------------------------------------------------------------------------

#define M33_ROT_Z(m,rz)                                 \
{                                                       \
   M33_SET(m,cos(rz),-sin(rz), 0.0,                     \
             sin(rz), cos(rz), 0.0,                     \
               0.0  ,   0.0  , 1.0 );                   \
}

//-----------------------------------------------------------------------------------------------

#define M33_FLIP_H(a,b)                                 \
{                                                       \
   M33_SET(a,b[2],b[1],b[0],                            \
             b[5],b[4],b[3],                            \
             b[8],b[7],b[6]);                           \
}

//-----------------------------------------------------------------------------------------------

#define M33_FLIP_V(a,b)                                 \
{                                                       \
   M33_SET(a,b[6],b[7],b[8],                            \
             b[3],b[4],b[5],                            \
             b[0],b[1],b[2]);                           \
}

//-----------------------------------------------------------------------------------------------
// Use Rich Cook's VTK plotting convention:
// R = Rx(a) Ry(b) Rz(c) where a, b, and c are three angles (radians)
//-----------------------------------------------------------------------------------------------

#define M33_EULER(m,a,b,c)                              \
{                                                       \
   real8 ca=cos(a), sa=sin(a);                          \
   real8 cb=cos(b), sb=sin(b);                          \
   real8 cc=cos(c), sc=sin(c);                          \
                                                        \
   (m)[0] =  cb*cc;                                     \
   (m)[1] = -cb*sc;                                     \
   (m)[2] =  sb;                                        \
   (m)[3] =  sa*sb*cc + ca*sc;                          \
   (m)[4] = -sa*sb*sc + ca*cc;                          \
   (m)[5] = -sa*cb;                                     \
   (m)[6] = -ca*sb*cc + sa*sc;                          \
   (m)[7] =  ca*sb*sc + sa*cc;                          \
   (m)[8] =  ca*cb;                                     \
}

//-----------------------------------------------------------------------------------------------

#define M33_QUAT(m,qx,qy,qz,qs)                         \
{                                                       \
   real8 x = (qx);                                      \
   real8 y = (qy);                                      \
   real8 z = (qz);                                      \
   real8 s = (qs);                                      \
                                                        \
   (m)[0] = (s*s) +  (x*x) - (y*y) - (z*z);             \
   (m)[1] =  2.0  * ((x*y) + (s*z));                    \
   (m)[2] =  2.0  * ((x*z) - (s*y));                    \
   (m)[3] =  2.0  * ((x*y) - (s*z));                    \
   (m)[4] = (s*s) -  (x*x) + (y*y) - (z*z);             \
   (m)[5] =  2.0  * ((y*z) + (s*x));                    \
   (m)[6] =  2.0  * ((x*z) + (s*y));                    \
   (m)[7] =  2.0  * ((y*z) - (s*x));                    \
   (m)[8] = (s*s) -  (x*x) - (y*y) + (z*z);             \
}

//-----------------------------------------------------------------------------------------------

#define M33_RIGHT_TO_LEFT(m)                            \
{                                                       \
   M33_SET(m, 1.0, 0.0, 0.0,                            \
              0.0,-1.0, 0.0,                            \
              0.0, 0.0, 1.0 );                          \
}

//-----------------------------------------------------------------------------------------------

#define M33_REFLECT_X(m)                                \
{                                                       \
   M33_SET(m,-1.0, 0.0, 0.0,                            \
              0.0, 1.0, 0.0,                            \
              0.0, 0.0, 1.0 );                          \
}

//-----------------------------------------------------------------------------------------------

#define M33_REFLECT_Y(m)                                \
{                                                       \
   M33_SET(m, 1.0, 0.0, 0.0,                            \
              0.0,-1.0, 0.0,                            \
              0.0, 0.0, 1.0 );                          \
}

//-----------------------------------------------------------------------------------------------

#define M33_REFLECT_Z(m)                                \
{                                                       \
   M33_SET(m, 1.0, 0.0, 0.0,                            \
              0.0, 1.0, 0.0,                            \
              0.0, 0.0,-1.0 );                          \
}

//-----------------------------------------------------------------------------------------------

#define M33_ECI_TO_SGI(m)                               \
{                                                       \
   M33_SET(m, 1.0, 0.0, 0.0,                            \
              0.0, 1.0, 0.0,                            \
              0.0, 0.0,-1.0 );                          \
}

//-----------------------------------------------------------------------------------------------

#define M33_MUL2(a,b)                                              \
{                                                                  \
   real8 _t[9]; memcpy(_t,(a),sizeof(_t));                         \
   (a)[0] = (_t[0]*(b)[0]) + (_t[1]*(b)[3]) + (_t[2]*(b)[6]);      \
   (a)[1] = (_t[0]*(b)[1]) + (_t[1]*(b)[4]) + (_t[2]*(b)[7]);      \
   (a)[2] = (_t[0]*(b)[2]) + (_t[1]*(b)[5]) + (_t[2]*(b)[8]);      \
                                                                   \
   (a)[3] = (_t[3]*(b)[0]) + (_t[4]*(b)[3]) + (_t[5]*(b)[6]);      \
   (a)[4] = (_t[3]*(b)[1]) + (_t[4]*(b)[4]) + (_t[5]*(b)[7]);      \
   (a)[5] = (_t[3]*(b)[2]) + (_t[4]*(b)[5]) + (_t[5]*(b)[8]);      \
                                                                   \
   (a)[6] = (_t[6]*(b)[0]) + (_t[7]*(b)[3]) + (_t[8]*(b)[6]);      \
   (a)[7] = (_t[6]*(b)[1]) + (_t[7]*(b)[4]) + (_t[8]*(b)[7]);      \
   (a)[8] = (_t[6]*(b)[2]) + (_t[7]*(b)[5]) + (_t[8]*(b)[8]);      \
}

//-----------------------------------------------------------------------------------------------

#define M33_MUL(a,b,c)                                             \
{                                                                  \
   (a)[0] = ((b)[0]*(c)[0]) + ((b)[1]*(c)[3]) + ((b)[2]*(c)[6]);   \
   (a)[1] = ((b)[0]*(c)[1]) + ((b)[1]*(c)[4]) + ((b)[2]*(c)[7]);   \
   (a)[2] = ((b)[0]*(c)[2]) + ((b)[1]*(c)[5]) + ((b)[2]*(c)[8]);   \
                                                                   \
   (a)[3] = ((b)[3]*(c)[0]) + ((b)[4]*(c)[3]) + ((b)[5]*(c)[6]);   \
   (a)[4] = ((b)[3]*(c)[1]) + ((b)[4]*(c)[4]) + ((b)[5]*(c)[7]);   \
   (a)[5] = ((b)[3]*(c)[2]) + ((b)[4]*(c)[5]) + ((b)[5]*(c)[8]);   \
                                                                   \
   (a)[6] = ((b)[6]*(c)[0]) + ((b)[7]*(c)[3]) + ((b)[8]*(c)[6]);   \
   (a)[7] = ((b)[6]*(c)[1]) + ((b)[7]*(c)[4]) + ((b)[8]*(c)[7]);   \
   (a)[8] = ((b)[6]*(c)[2]) + ((b)[7]*(c)[5]) + ((b)[8]*(c)[8]);   \
}

//-----------------------------------------------------------------------------------------------

#define M33_MUL_MS(a,b,s)                                          \
{                                                                  \
   (a)[0]=((b)[0]*(s)); (a)[1]=((b)[1]*(s)); (a)[2]=((b)[2]*(s));  \
   (a)[3]=((b)[3]*(s)); (a)[4]=((b)[4]*(s)); (a)[5]=((b)[5]*(s));  \
   (a)[6]=((b)[6]*(s)); (a)[7]=((b)[7]*(s)); (a)[8]=((b)[8]*(s));  \
}

//-----------------------------------------------------------------------------------------------

#define M33_MUL_SM(a,s,b)                                          \
{                                                                  \
   (a)[0]=((s)*(b)[0]); (a)[1]=((s)*(b)[1]); (a)[2]=((s)*(b)[2]);  \
   (a)[3]=((s)*(b)[3]); (a)[4]=((s)*(b)[4]); (a)[5]=((s)*(b)[5]);  \
   (a)[6]=((s)*(b)[6]); (a)[7]=((s)*(b)[7]); (a)[8]=((s)*(b)[8]);  \
}

//-----------------------------------------------------------------------------------------------

#define M33_DET(m)                \
(                                 \
     ((m)[0] * (m)[4] * (m)[8])   \
   + ((m)[1] * (m)[5] * (m)[6])   \
   + ((m)[2] * (m)[3] * (m)[7])   \
   - ((m)[2] * (m)[4] * (m)[6])   \
   - ((m)[1] * (m)[3] * (m)[8])   \
   - ((m)[0] * (m)[5] * (m)[7])   \
)

//-----------------------------------------------------------------------------------------------

#define M33_INV(a,b)                                 \
{                                                    \
   real8 det = M33_DET(b);                           \
         det = ( (fabs(det)>0.0) ? 1.0/det : 0.0 );  \
                                                     \
   (a)[0] = det * ((b)[4]*(b)[8] - (b)[5]*(b)[7]);   \
   (a)[1] = det * ((b)[2]*(b)[7] - (b)[1]*(b)[8]);   \
   (a)[2] = det * ((b)[1]*(b)[5] - (b)[2]*(b)[4]);   \
   (a)[3] = det * ((b)[5]*(b)[6] - (b)[3]*(b)[8]);   \
   (a)[4] = det * ((b)[0]*(b)[8] - (b)[2]*(b)[6]);   \
   (a)[5] = det * ((b)[2]*(b)[3] - (b)[0]*(b)[5]);   \
   (a)[6] = det * ((b)[3]*(b)[7] - (b)[4]*(b)[6]);   \
   (a)[7] = det * ((b)[1]*(b)[6] - (b)[0]*(b)[7]);   \
   (a)[8] = det * ((b)[0]*(b)[4] - (b)[1]*(b)[3]);   \
}

#define M33_ADJOINT(a,b)                             \
{                                                    \
   (a)[0] = ((b)[4]*(b)[8] - (b)[5]*(b)[7]);         \
   (a)[1] = ((b)[2]*(b)[7] - (b)[1]*(b)[8]);         \
   (a)[2] = ((b)[1]*(b)[5] - (b)[2]*(b)[4]);         \
   (a)[3] = ((b)[5]*(b)[6] - (b)[3]*(b)[8]);         \
   (a)[4] = ((b)[0]*(b)[8] - (b)[2]*(b)[6]);         \
   (a)[5] = ((b)[2]*(b)[3] - (b)[0]*(b)[5]);         \
   (a)[6] = ((b)[3]*(b)[7] - (b)[4]*(b)[6]);         \
   (a)[7] = ((b)[1]*(b)[6] - (b)[0]*(b)[7]);         \
   (a)[8] = ((b)[0]*(b)[4] - (b)[1]*(b)[3]);         \
}

//-----------------------------------------------------------------------------------------------

#define M33_TRANSPOSE(q,p)               \
{                                        \
   M33_SET(q, (p)[0], (p)[3], (p)[6],    \
              (p)[1], (p)[4], (p)[7],    \
              (p)[2], (p)[5], (p)[8] );  \
}

//-----------------------------------------------------------------------------------------------

#define M33_NEG(a,b)     \
{                        \
   (a)[0]= -((b)[0]);    \
   (a)[1]= -((b)[1]);    \
   (a)[2]= -((b)[2]);    \
   (a)[3]= -((b)[3]);    \
   (a)[4]= -((b)[4]);    \
   (a)[5]= -((b)[5]);    \
   (a)[6]= -((b)[6]);    \
   (a)[7]= -((b)[7]);    \
   (a)[8]= -((b)[8]);    \
}

//-----------------------------------------------------------------------------------------------

#define M33_ABS(a,b)     \
{                        \
   (a)[0]=fabs((b)[0]);  \
   (a)[1]=fabs((b)[1]);  \
   (a)[2]=fabs((b)[2]);  \
   (a)[3]=fabs((b)[3]);  \
   (a)[4]=fabs((b)[4]);  \
   (a)[5]=fabs((b)[5]);  \
   (a)[6]=fabs((b)[6]);  \
   (a)[7]=fabs((b)[7]);  \
   (a)[8]=fabs((b)[8]);  \
}

//-----------------------------------------------------------------------------------------------

#define M33_RINT(a,b)    \
{                        \
   (a)[0]=rint((b)[0]);  \
   (a)[1]=rint((b)[1]);  \
   (a)[2]=rint((b)[2]);  \
   (a)[3]=rint((b)[3]);  \
   (a)[4]=rint((b)[4]);  \
   (a)[5]=rint((b)[5]);  \
   (a)[6]=rint((b)[6]);  \
   (a)[7]=rint((b)[7]);  \
   (a)[8]=rint((b)[8]);  \
}

//-----------------------------------------------------------------------------------------------

#define M33_SIGN(a,b)    \
{                        \
   (a)[0]=( ((b)[0]<0.0) ? -1.0 : ( (((b)[0]>0.0)) ? +1.0 : 0.0) ); \
   (a)[1]=( ((b)[1]<0.0) ? -1.0 : ( (((b)[1]>0.0)) ? +1.0 : 0.0) ); \
   (a)[2]=( ((b)[2]<0.0) ? -1.0 : ( (((b)[2]>0.0)) ? +1.0 : 0.0) ); \
   (a)[3]=( ((b)[3]<0.0) ? -1.0 : ( (((b)[3]>0.0)) ? +1.0 : 0.0) ); \
   (a)[4]=( ((b)[4]<0.0) ? -1.0 : ( (((b)[4]>0.0)) ? +1.0 : 0.0) ); \
   (a)[5]=( ((b)[5]<0.0) ? -1.0 : ( (((b)[5]>0.0)) ? +1.0 : 0.0) ); \
   (a)[6]=( ((b)[6]<0.0) ? -1.0 : ( (((b)[6]>0.0)) ? +1.0 : 0.0) ); \
   (a)[7]=( ((b)[7]<0.0) ? -1.0 : ( (((b)[7]>0.0)) ? +1.0 : 0.0) ); \
   (a)[8]=( ((b)[8]<0.0) ? -1.0 : ( (((b)[8]>0.0)) ? +1.0 : 0.0) ); \
}

//-----------------------------------------------------------------------------------------------

#define M33_NORMALIZE(a,b)                               \
{                                                        \
   real8 s =      fabs((b)[0]);                          \
         s = ( (s>fabs((b)[1])) ? s : fabs((b)[1]) );    \
         s = ( (s>fabs((b)[2])) ? s : fabs((b)[2]) );    \
         s = ( (s>fabs((b)[3])) ? s : fabs((b)[3]) );    \
         s = ( (s>fabs((b)[4])) ? s : fabs((b)[4]) );    \
         s = ( (s>fabs((b)[5])) ? s : fabs((b)[5]) );    \
         s = ( (s>fabs((b)[6])) ? s : fabs((b)[6]) );    \
         s = ( (s>fabs((b)[7])) ? s : fabs((b)[7]) );    \
         s = ( (s>fabs((b)[8])) ? s : fabs((b)[8]) );    \
                                                         \
         s = ( (s>0.0) ? (1.0/s) : 0.0 );                \
                                                         \
   (a)[0]=s*((b)[0]);                                    \
   (a)[1]=s*((b)[1]);                                    \
   (a)[2]=s*((b)[2]);                                    \
   (a)[3]=s*((b)[3]);                                    \
   (a)[4]=s*((b)[4]);                                    \
   (a)[5]=s*((b)[5]);                                    \
   (a)[6]=s*((b)[6]);                                    \
   (a)[7]=s*((b)[7]);                                    \
   (a)[8]=s*((b)[8]);                                    \
}

//-----------------------------------------------------------------------------------------------

#define V3_M33_V3_MUL(q,m,p)                      \
{                                                 \
   real8 _x = (p)[0];                             \
   real8 _y = (p)[1];                             \
   real8 _z = (p)[2];                             \
                                                  \
   (q)[0] = ((m)[0]*_x)+((m)[1]*_y)+((m)[2]*_z);  \
   (q)[1] = ((m)[3]*_x)+((m)[4]*_y)+((m)[5]*_z);  \
   (q)[2] = ((m)[6]*_x)+((m)[7]*_y)+((m)[8]*_z);  \
}

//-----------------------------------------------------------------------------------------------

#define V3_V3_M33_MUL(q,p,m)                      \
{                                                 \
   real8 _x = (p)[0];                             \
   real8 _y = (p)[1];                             \
   real8 _z = (p)[2];                             \
                                                  \
   (q)[0] = (_x*(m)[0])+(_y*(m)[3])+(_z*(m)[6]);  \
   (q)[1] = (_x*(m)[1])+(_y*(m)[4])+(_z*(m)[7]);  \
   (q)[2] = (_x*(m)[2])+(_y*(m)[5])+(_z*(m)[8]);  \
}

//-----------------------------------------------------------------------------------------------

#define MUL_M33_V3N(m,v,n)                        \
{                                                 \
   if (m && v && ((n)>0))                         \
   {                                              \
      for (int i=0,k=0; (i<n); ++i,k+=3)          \
      {                                           \
         real8 x = v[k  ];                        \
         real8 y = v[k+1];                        \
         real8 z = v[k+2];                        \
                                                  \
         v[k  ] = (m[0]*x)+(m[1]*y)+(m[2]*z);     \
         v[k+1] = (m[3]*x)+(m[4]*y)+(m[5]*z);     \
         v[k+2] = (m[6]*x)+(m[7]*y)+(m[8]*z);     \
      }                                           \
   }                                              \
}

//-----------------------------------------------------------------------------------------------

#define MUL_V3N_M33(m,v,n)                        \
{                                                 \
   if (m && v && ((n)>0))                         \
   {                                              \
      for (int i=0,k=0; (i<n); ++i,k+=3)          \
      {                                           \
         real8 x = v[k  ];                        \
         real8 y = v[k+1];                        \
         real8 z = v[k+2];                        \
                                                  \
         v[k  ] = (x*m[0])+(y*m[3])+(z*m[6]);     \
         v[k+1] = (x*m[1])+(y*m[4])+(z*m[7]);     \
         v[k+2] = (x*m[2])+(y*m[5])+(z*m[8]);     \
      }                                           \
   }                                              \
}

//-----------------------------------------------------------------------------------------------

#define MUL_V3N_M33_V3N(a,m,b,n)                  \
{                                                 \
   if (a && m && b && ((n)>0))                    \
   {                                              \
      for (int i=0,k=0; (i<n); ++i,k+=3)          \
      {                                           \
         real8 x = b[k  ];                        \
         real8 y = b[k+1];                        \
         real8 z = b[k+2];                        \
                                                  \
         a[k  ] = (m[0]*x)+(m[1]*y)+(m[2]*z);     \
         a[k+1] = (m[3]*x)+(m[4]*y)+(m[5]*z);     \
         a[k+2] = (m[6]*x)+(m[7]*y)+(m[8]*z);     \
      }                                           \
   }                                              \
}

//-----------------------------------------------------------------------------------------------

#define MUL_V3N_V3N_M33(a,b,m,n)                  \
{                                                 \
   if (a && b && m && ((n)>0))                    \
   {                                              \
      for (int i=0,k=0; (i<n); ++i,k+=3)          \
      {                                           \
         real8 x = b[k  ];                        \
         real8 y = b[k+1];                        \
         real8 z = b[k+2];                        \
                                                  \
         a[k  ] = (x*m[0])+(y*m[3])+(z*m[6]);     \
         a[k+1] = (x*m[1])+(y*m[4])+(z*m[7]);     \
         a[k+2] = (x*m[2])+(y*m[5])+(z*m[8]);     \
      }                                           \
   }                                              \
}

//-----------------------------------------------------------------------------------------------

#define M33_FOR_ALL(fn) { for (int i=0; (i<9); ++i) { fn; } }

//-----------------------------------------------------------------------------------------------

#define  M33_SIN(a,b)               { M33_FOR_ALL( (a)[i]=sin((b)[i]) ) }
#define  M33_COS(a,b)               { M33_FOR_ALL( (a)[i]=cos((b)[i]) ) }
#define  M33_TAN(a,b)               { M33_FOR_ALL( (a)[i]=tan((b)[i]) ) }
#define  M33_LOG(a,b)               { M33_FOR_ALL( (a)[i]=(((b)[i]>0.0) ? log  ((b)[i]) : 0.0) ) }
#define  M33_LOG2(a,b)              { M33_FOR_ALL( (a)[i]=(((b)[i]>0.0) ? log2 ((b)[i]) : 0.0) ) }
#define  M33_LOG10(a,b)             { M33_FOR_ALL( (a)[i]=(((b)[i]>0.0) ? log10((b)[i]) : 0.0) ) }
#define  M33_SQR(a,b)               { M33_FOR_ALL( (a)[i]=(b)[i]*(b)[i] ) }
#define  M33_SQRT(a,b)              { M33_FOR_ALL( (a)[i]=(((b)[i]>0.0) ? sqrt ((b)[i]) : 0.0) ) }

#define  M33_THRESHOLD(a,b,s)       { M33_FOR_ALL( (a)[i]=( (fabs((b)[i])<(s)) ? 0.0    : (b)[i] ) ) }
#define  M33_CAP(a,b,max)           { M33_FOR_ALL( (a)[i]=( ((b)[i]<(max))     ? (b)[i] : (max)  ) ) }
#define  M33_CONSTRAIN(a,b,min,max) { M33_FOR_ALL( (a)[i]=( ((b)[i]<(min))     ? (min)  : ( ((b)[i]<(max)) ? (b)[i] : (max) ) ) ) }

//-----------------------------------------------------------------------------------------------

class Matrix_3x3
{
   public :
      real8  mtx[9];

   public :
       Matrix_3x3(void)                     { M33_ZERO(mtx);       }
       Matrix_3x3(const Matrix_3x3     & m) { M33_COPY(mtx,m.mtx); }

       Matrix_3x3(const unsigned char    s) {          M33_SET1(mtx,s);   }
       Matrix_3x3(const unsigned short   s) {          M33_SET1(mtx,s);   }
       Matrix_3x3(const          short   s) {          M33_SET1(mtx,s);   }
       Matrix_3x3(const unsigned int     s) {          M33_SET1(mtx,s);   }
       Matrix_3x3(const          int     s) {          M33_SET1(mtx,s);   }
       Matrix_3x3(const          real8   s) {          M33_SET1(mtx,s);   }

       Matrix_3x3(const unsigned char   *s) { if (s) { M33_COPY(mtx,s); } }
       Matrix_3x3(const unsigned short  *s) { if (s) { M33_COPY(mtx,s); } }
       Matrix_3x3(const          short  *s) { if (s) { M33_COPY(mtx,s); } }
       Matrix_3x3(const unsigned int    *s) { if (s) { M33_COPY(mtx,s); } }
       Matrix_3x3(const          int    *s) { if (s) { M33_COPY(mtx,s); } }
       Matrix_3x3(const          real8  *s) { if (s) { M33_COPY(mtx,s); } }

       Matrix_3x3(const real8 m00, const real8 m01,
                  const real8 m10, const real8 m11                  ) { M33_SET(mtx,m00,m01,0.0,
                                                                                    m10,m11,0.0,
                                                                                    0.0,0.0,1.0); }

       Matrix_3x3(const real8 m00, const real8 m11, const real8 m22,
                  const real8 m12, const real8 m20, const real8 m01 ) { M33_SET_TENSOR(mtx,m00,m11,m22,
                                                                                           m12,m20,m01); }

       Matrix_3x3(const real8 m00, const real8 m01, const real8 m02,
                  const real8 m10, const real8 m11, const real8 m12,
                  const real8 m20, const real8 m21, const real8 m22 ) { M33_SET(mtx,m00,m01,m02,
                                                                                    m10,m11,m12,
                                                                                    m20,m21,m22); }

      ~Matrix_3x3() {}

      const Matrix_3x3 & operator =  (const Matrix_3x3     & m) { M33_COPY(mtx,m.mtx); return(*this); }

      const Matrix_3x3 & operator =  (const unsigned char    s) { M33_SET1(mtx,s); return(*this); }
      const Matrix_3x3 & operator =  (const unsigned short   s) { M33_SET1(mtx,s); return(*this); }
      const Matrix_3x3 & operator =  (const          short   s) { M33_SET1(mtx,s); return(*this); }
      const Matrix_3x3 & operator =  (const unsigned int     s) { M33_SET1(mtx,s); return(*this); }
      const Matrix_3x3 & operator =  (const          int     s) { M33_SET1(mtx,s); return(*this); }
      const Matrix_3x3 & operator =  (const          real8   s) { M33_SET1(mtx,s); return(*this); }

      const Matrix_3x3 & operator =  (const unsigned char   *s) { if (s) { M33_COPY(mtx,s); } return(*this); }
      const Matrix_3x3 & operator =  (const unsigned short  *s) { if (s) { M33_COPY(mtx,s); } return(*this); }
      const Matrix_3x3 & operator =  (const          short  *s) { if (s) { M33_COPY(mtx,s); } return(*this); }
      const Matrix_3x3 & operator =  (const unsigned int    *s) { if (s) { M33_COPY(mtx,s); } return(*this); }
      const Matrix_3x3 & operator =  (const          int    *s) { if (s) { M33_COPY(mtx,s); } return(*this); }
      const Matrix_3x3 & operator =  (const          real8  *s) { if (s) { M33_COPY(mtx,s); } return(*this); }

            void         operator += (const Matrix_3x3     & m) { M33_ADD   (mtx,mtx,m.mtx); }
            void         operator += (const real8            s) { M33_ADD_MS(mtx,mtx,s    ); }
            void         operator -= (const Matrix_3x3     & m) { M33_SUB   (mtx,mtx,m.mtx); }
            void         operator -= (const real8            s) { M33_SUB_MS(mtx,mtx,s    ); }
            void         operator *= (const Matrix_3x3     & m) { Matrix_3x3 tmp(*this); M33_MUL(mtx,tmp.mtx,m.mtx); }
            void         operator *= (const real8            s) { M33_MUL_MS(mtx,mtx,s    ); }
            void         operator /= (const real8            s) { real8 x = ( (fabs(s)>0.0) ? 1.0/s : 0.0 ); M33_MUL_MS(mtx,mtx,x); }

            Matrix_3x3   operator +  (const Matrix_3x3     & m) { Matrix_3x3 tmp(*this); tmp+=m; return(tmp); }
            Matrix_3x3   operator +  (const real8            s) { Matrix_3x3 tmp(*this); tmp+=s; return(tmp); }
            Matrix_3x3   operator -  (const Matrix_3x3     & m) { Matrix_3x3 tmp(*this); tmp-=m; return(tmp); }
            Matrix_3x3   operator -  (const real8            s) { Matrix_3x3 tmp(*this); tmp-=s; return(tmp); }
            Matrix_3x3   operator *  (const Matrix_3x3     & m) { Matrix_3x3 tmp, tmp2(*this); M33_MUL(tmp.mtx,tmp2.mtx,m.mtx); return(tmp); }
            Matrix_3x3   operator *  (const real8            s) { Matrix_3x3 tmp(*this); tmp*=s; return(tmp); }

            Matrix_3x3   operator - ()                          { Matrix_3x3 tmp; M33_NEG(tmp.mtx,mtx); return(tmp); }

                         operator  real8  *() const { return ( (real8  *) mtx ); }

      real8 Dot           (const Matrix_3x3 & m) const { real8 s=0.0; M33_DOT(s,mtx,m.mtx); return(s); }

      void  Transpose     (void)                       { Matrix_3x3 tmp(*this); M33_TRANSPOSE(mtx,tmp.mtx); }
      void  Transpose     (const Matrix_3x3 & m )      { Matrix_3x3 tmp(m);     M33_TRANSPOSE(mtx,tmp.mtx); }

      void  Normalize     (void)                       { M33_NORMALIZE(mtx,  mtx); }
      void  Normalize     (const Matrix_3x3 & m )      { M33_NORMALIZE(mtx,m.mtx); }

      real8 Determinant   (void)                       { return(M33_DET(mtx)); }

      real8 Norm          (void)                       { real8 r0   = fabs(mtx[0])+fabs(mtx[1])+fabs(mtx[2]);
                                                         real8 r1   = fabs(mtx[3])+fabs(mtx[4])+fabs(mtx[5]);
                                                         real8 r2   = fabs(mtx[6])+fabs(mtx[7])+fabs(mtx[8]);
                                                         real8 norm = ( (r0>r1) ? ( (r0>r2) ? r0 : r2 ) : ( (r1>r2) ? r1 : r2 ) );
                                                         return(norm);
                                                       }

      void  Inverse       (void)                       { Matrix_3x3 tmp(*this); M33_INV(mtx,tmp.mtx); }
      void  Inverse       (const Matrix_3x3 & m )      { Matrix_3x3 tmp(m);     M33_INV(mtx,tmp.mtx); }

      int   Compare       (const Matrix_3x3 & m, const real8 eps=4.0e-8) const;
      int   Compare       (const real8        s, const real8 eps=4.0e-8) const;
      int   Compare       (const real8       *s, const real8 eps=4.0e-8) const;

      int   Near          (const Matrix_3x3 & m, const real8 eps=4.0e-8) const { return( Compare(m,eps) ? 1 : 0 ); }
      int   Near          (const real8        s, const real8 eps=4.0e-8) const { return( Compare(s,eps) ? 1 : 0 ); }
      int   Near          (const real8       *s, const real8 eps=4.0e-8) const { return( Compare(s,eps) ? 1 : 0 ); }

      int   operator ==   (const Matrix_3x3 & m) const { return( Compare(m) ? 1 : 0 ); }
      int   operator ==   (const real8        s) const { return( Compare(s) ? 1 : 0 ); }
      int   operator ==   (const real8       *s) const { return( Compare(s) ? 1 : 0 ); }

      int   operator !=   (const Matrix_3x3 & m) const { return( Compare(m) ? 0 : 1 ); }
      int   operator !=   (const real8        s) const { return( Compare(s) ? 0 : 1 ); }
      int   operator !=   (const real8       *s) const { return( Compare(s) ? 0 : 1 ); }

      int   operator <    (const Matrix_3x3 & m) const { M33_FOR_ALL( if(mtx[i]>=m.mtx[i]) return(0) )  return(1); }
      int   operator <    (const real8        s) const { M33_FOR_ALL( if(mtx[i]>=s       ) return(0) )  return(1); }
      int   operator <    (const real8       *s) const { if (!s) return(0);
                                                         M33_FOR_ALL( if(mtx[i]>=s[i]    ) return(0) ) return(1); }

      int   operator <=   (const Matrix_3x3 & m) const { M33_FOR_ALL( if(mtx[i]> m.mtx[i]) return(0) ) return(1); }
      int   operator <=   (const real8        s) const { M33_FOR_ALL( if(mtx[i]> s       ) return(0) ) return(1); }
      int   operator <=   (const real8       *s) const { if (!s) return(0);
                                                         M33_FOR_ALL( if(mtx[i]> s[i]    ) return(0) ) return(1); }

      int   operator >    (const Matrix_3x3 & m) const { M33_FOR_ALL( if(mtx[i]<=m.mtx[i]) return(0) ) return(1); }
      int   operator >    (const real8        s) const { M33_FOR_ALL( if(mtx[i]<=s       ) return(0) ) return(1); }
      int   operator >    (const real8       *s) const { if (!s) return(0);
                                                         M33_FOR_ALL( if(mtx[i]<=s[i]    ) return(0) ) return(1); }

      int   operator >=   (const Matrix_3x3 & m) const { M33_FOR_ALL( if(mtx[i]< m.mtx[i]) return(0) ) return(1); }
      int   operator >=   (const real8        s) const { M33_FOR_ALL( if(mtx[i]< s       ) return(0) ) return(1); }
      int   operator >=   (const real8       *s) const { if (!s) return(0);
                                                         M33_FOR_ALL( if(mtx[i]< s[i]    ) return(0) ) return(1); }

      void  Identity      (void) { M33_IDENTITY(mtx); }
      void  Zero          (void) { M33_ZERO    (mtx); }
      void  One           (void) { M33_ONE     (mtx); }
      void  Pascal        (void) { M33_PASCAL  (mtx); }
      void  Hilbert       (void) { M33_HILBERT (mtx); }

      void  Rand          (const real8 min=0.0, const real8 max=1.0) { M33_RAND(mtx,min,max); }

      void  Abs           (void)                 { M33_ABS  (mtx,  mtx); }
      void  Abs           (const Matrix_3x3 & m) { M33_ABS  (mtx,m.mtx); }
      void  Rint          (void)                 { M33_RINT (mtx,  mtx); }
      void  Rint          (const Matrix_3x3 & m) { M33_RINT (mtx,m.mtx); }
      void  Sign          (void)                 { M33_SIGN (mtx,  mtx); }
      void  Sign          (const Matrix_3x3 & m) { M33_SIGN (mtx,m.mtx); }

      void  Sin           (void)                 { M33_SIN  (mtx,  mtx); }
      void  Sin           (const Matrix_3x3 & m) { M33_SIN  (mtx,m.mtx); }
      void  Cos           (void)                 { M33_COS  (mtx,  mtx); }
      void  Cos           (const Matrix_3x3 & m) { M33_COS  (mtx,m.mtx); }
      void  Tan           (void)                 { M33_TAN  (mtx,  mtx); }
      void  Tan           (const Matrix_3x3 & m) { M33_TAN  (mtx,m.mtx); }
      void  Log           (void)                 { M33_LOG  (mtx,  mtx); }
      void  Log           (const Matrix_3x3 & m) { M33_LOG  (mtx,m.mtx); }
      void  Log2          (void)                 { M33_LOG2 (mtx,  mtx); }
      void  Log2          (const Matrix_3x3 & m) { M33_LOG2 (mtx,m.mtx); }
      void  Log10         (void)                 { M33_LOG10(mtx,  mtx); }
      void  Log10         (const Matrix_3x3 & m) { M33_LOG10(mtx,m.mtx); }
      void  Sqr           (void)                 { M33_SQR  (mtx,  mtx); }
      void  Sqr           (const Matrix_3x3 & m) { M33_SQR  (mtx,m.mtx); }
      void  Sqrt          (void)                 { M33_SQRT (mtx,  mtx); }
      void  Sqrt          (const Matrix_3x3 & m) { M33_SQRT (mtx,m.mtx); }

      void  Threshold     (const real8 eps)                                        { M33_THRESHOLD(mtx,  mtx,eps); }
      void  Threshold     (const Matrix_3x3 & m, const real8 eps)                  { M33_THRESHOLD(mtx,m.mtx,eps); }

      void  Cap           (const real8 max)                                        { M33_CAP      (mtx,  mtx,max); }
      void  Cap           (const Matrix_3x3 & m, const real8 max)                  { M33_CAP      (mtx,m.mtx,max); }

      void  Constrain     (const real8 min, const real8 max)                       { M33_CONSTRAIN(mtx,  mtx,min,max); }
      void  Constrain     (const Matrix_3x3 & m, const real8 min, const real8 max) { M33_CONSTRAIN(mtx,m.mtx,min,max); }

      void  Translate     (const real8 tx,
                           const real8 ty) { M33_TRANSLATE(mtx,tx,ty); }

      void  Scale         (const real8 sx, const real8 sy, const real8 sz)         { M33_SCALE   (mtx,sx,sy,sz); }
      void  Diag          (const real8 sx, const real8 sy, const real8 sz)         { M33_DIAG    (mtx,sx,sy,sz); }

      void  Rotate_X      (const real8 rx) { M33_ROT_X(mtx,rx); }
      void  Rotate_Y      (const real8 ry) { M33_ROT_Y(mtx,ry); }
      void  Rotate_Z      (const real8 rz) { M33_ROT_Z(mtx,rz); }

      void  Flip_H        (void)                  { real8 tmp[9];  M33_COPY(tmp,  mtx); M33_FLIP_H(mtx,tmp); }
      void  Flip_H        (const Matrix_3x3 & m)  { real8 tmp[9];  M33_COPY(tmp,m.mtx); M33_FLIP_H(mtx,tmp); }
      void  Flip_V        (void)                  { real8 tmp[9];  M33_COPY(tmp,  mtx); M33_FLIP_V(mtx,tmp); }
      void  Flip_V        (const Matrix_3x3 & m)  { real8 tmp[9];  M33_COPY(tmp,m.mtx); M33_FLIP_V(mtx,tmp); }

      void  Euler         (const real8 a ,
                           const real8 b ,
                           const real8 c ) { M33_EULER(mtx,a,b,c); }

      void  Quat          (const real8 qx ,
                           const real8 qy ,
                           const real8 qz ,
                           const real8 qs ) { M33_QUAT(mtx,qx,qy,qz,qs); }

      void  Right_To_Left (void)           { M33_RIGHT_TO_LEFT(mtx); }
      void  Reflect_X     (void)           { M33_REFLECT_X    (mtx); }
      void  Reflect_Y     (void)           { M33_REFLECT_Y    (mtx); }
      void  Reflect_Z     (void)           { M33_REFLECT_Z    (mtx); }
      void  ECI_To_SGI    (void)           { M33_ECI_TO_SGI   (mtx); }

      void  Transform_M33_V3N (real8 *v ,                  const int n) const { MUL_M33_V3N    (mtx,v,n);     }
      void  Transform_V3N_M33 (real8 *v ,                  const int n) const { MUL_V3N_M33    (mtx,v,n);     }
      void  Transform_M33_V3N (real8 *va, const real8 *vb, const int n) const { MUL_V3N_M33_V3N(va,mtx,vb,n); }
      void  Transform_V3N_M33 (real8 *va, const real8 *vb, const int n) const { MUL_V3N_V3N_M33(va,vb,mtx,n); }

      void  Print         (FILE *fd=stdout, const char *fmt="%8.4lf ") const;
};

//-----------------------------------------------------------------------------------------------

inline Matrix_3x3 M33_Identity      (void) { Matrix_3x3 m; M33_IDENTITY     (m.mtx); return(m); }
inline Matrix_3x3 M33_Zero          (void) { Matrix_3x3 m; M33_ZERO         (m.mtx); return(m); }
inline Matrix_3x3 M33_One           (void) { Matrix_3x3 m; M33_ONE          (m.mtx); return(m); }
inline Matrix_3x3 M33_Pascal        (void) { Matrix_3x3 m; M33_PASCAL       (m.mtx); return(m); }
inline Matrix_3x3 M33_Hilbert       (void) { Matrix_3x3 m; M33_HILBERT      (m.mtx); return(m); }

inline Matrix_3x3 M33_Right_To_Left (void) { Matrix_3x3 m; M33_RIGHT_TO_LEFT(m.mtx); return(m); }
inline Matrix_3x3 M33_Reflect_X     (void) { Matrix_3x3 m; M33_REFLECT_X    (m.mtx); return(m); }
inline Matrix_3x3 M33_Reflect_Y     (void) { Matrix_3x3 m; M33_REFLECT_Y    (m.mtx); return(m); }
inline Matrix_3x3 M33_Reflect_Z     (void) { Matrix_3x3 m; M33_REFLECT_Z    (m.mtx); return(m); }
inline Matrix_3x3 M33_ECI_To_SGI    (void) { Matrix_3x3 m; M33_ECI_TO_SGI   (m.mtx); return(m); }

extern int  M33_Near  (M33 ma, const M33   mb);
extern int  M33_Near  (M33 ma, const M33   mb, const real8 eps);
extern int  M33_Near  (M33 m , const real8 b , const real8 eps);

extern int  M33_Near  (M33 m        , const real8 m00, const real8 m01, const real8 m02,
                                      const real8 m10, const real8 m11, const real8 m12,
                                      const real8 m20, const real8 m21, const real8 m22, const real8 eps);

extern int  M33_Near  (real8 m[3][3], const real8 m00, const real8 m01, const real8 m02,
                                      const real8 m10, const real8 m11, const real8 m12,
                                      const real8 m20, const real8 m21, const real8 m22, const real8 eps);

extern void M33_Print (const M33 m, const char *title);

#endif
